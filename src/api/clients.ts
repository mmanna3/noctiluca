// ----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
// ----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
	) {
		this.http = http ? http : (window as any);
		this.baseUrl = baseUrl ?? "";
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	login(body: LoginDTO | undefined): Promise<LoginResponseDTO> {
		let url_ = this.baseUrl + "/api/Auth/login";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processLogin(_response);
		});
	}

	protected processLogin(response: Response): Promise<LoginResponseDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = LoginResponseDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<LoginResponseDTO>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	cambiarPassword(body: CambiarPasswordDTO | undefined): Promise<LoginResponseDTO> {
		let url_ = this.baseUrl + "/api/Auth/cambiar-password";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCambiarPassword(_response);
		});
	}

	protected processCambiarPassword(response: Response): Promise<LoginResponseDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = LoginResponseDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<LoginResponseDTO>(null as any);
	}

	/**
	 * @return Success
	 */
	carpetaAll(): Promise<CarpetaDTO[]> {
		let url_ = this.baseUrl + "/api/Carpeta";
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaAll(_response);
		});
	}

	protected processCarpetaAll(response: Response): Promise<CarpetaDTO[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(CarpetaDTO.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<CarpetaDTO[]>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	carpetaPOST(body: CarpetaDTO | undefined): Promise<CarpetaDTO> {
		let url_ = this.baseUrl + "/api/Carpeta";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaPOST(_response);
		});
	}

	protected processCarpetaPOST(response: Response): Promise<CarpetaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CarpetaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<CarpetaDTO>(null as any);
	}

	/**
	 * @return Success
	 */
	carpetaGET(id: number): Promise<CarpetaDTO> {
		let url_ = this.baseUrl + "/api/Carpeta/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaGET(_response);
		});
	}

	protected processCarpetaGET(response: Response): Promise<CarpetaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CarpetaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<CarpetaDTO>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	carpetaPUT(id: number, body: CarpetaDTO | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/Carpeta/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaPUT(_response);
		});
	}

	protected processCarpetaPUT(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @return Success
	 */
	carpetaDELETE(id: number): Promise<void> {
		let url_ = this.baseUrl + "/api/Carpeta/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "DELETE",
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaDELETE(_response);
		});
	}

	protected processCarpetaDELETE(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @return Success
	 */
	notaAll(): Promise<NotaDTO[]> {
		let url_ = this.baseUrl + "/api/Nota";
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaAll(_response);
		});
	}

	protected processNotaAll(response: Response): Promise<NotaDTO[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(NotaDTO.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<NotaDTO[]>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	notaPOST(body: NotaDTO | undefined): Promise<NotaDTO> {
		let url_ = this.baseUrl + "/api/Nota";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaPOST(_response);
		});
	}

	protected processNotaPOST(response: Response): Promise<NotaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = NotaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<NotaDTO>(null as any);
	}

	/**
	 * @return Success
	 */
	notaGET(id: number): Promise<NotaDTO> {
		let url_ = this.baseUrl + "/api/Nota/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaGET(_response);
		});
	}

	protected processNotaGET(response: Response): Promise<NotaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = NotaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<NotaDTO>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	notaPUT(id: number, body: NotaDTO | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/Nota/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaPUT(_response);
		});
	}

	protected processNotaPUT(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @return Success
	 */
	notaDELETE(id: number): Promise<void> {
		let url_ = this.baseUrl + "/api/Nota/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "DELETE",
			headers: {},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaDELETE(_response);
		});
	}

	protected processNotaDELETE(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}
}

export class CambiarPasswordDTO implements ICambiarPasswordDTO {
	usuario!: string;
	passwordNuevo!: string;

	constructor(data?: ICambiarPasswordDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.usuario = _data["usuario"];
			this.passwordNuevo = _data["passwordNuevo"];
		}
	}

	static fromJS(data: any): CambiarPasswordDTO {
		data = typeof data === "object" ? data : {};
		let result = new CambiarPasswordDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["usuario"] = this.usuario;
		data["passwordNuevo"] = this.passwordNuevo;
		return data;
	}
}

export interface ICambiarPasswordDTO {
	usuario: string;
	passwordNuevo: string;
}

export class CarpetaDTO implements ICarpetaDTO {
	id?: number;
	titulo!: string;
	notas?: NotaDTO[] | undefined;
	readonly cantidadDeNotas?: number;
	requiereAutenticacion?: boolean;

	constructor(data?: ICarpetaDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.titulo = _data["titulo"];
			if (Array.isArray(_data["notas"])) {
				this.notas = [] as any;
				for (let item of _data["notas"]) this.notas!.push(NotaDTO.fromJS(item));
			}
			(<any>this).cantidadDeNotas = _data["cantidadDeNotas"];
			this.requiereAutenticacion = _data["requiereAutenticacion"];
		}
	}

	static fromJS(data: any): CarpetaDTO {
		data = typeof data === "object" ? data : {};
		let result = new CarpetaDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["id"] = this.id;
		data["titulo"] = this.titulo;
		if (Array.isArray(this.notas)) {
			data["notas"] = [];
			for (let item of this.notas) data["notas"].push(item.toJSON());
		}
		data["cantidadDeNotas"] = this.cantidadDeNotas;
		data["requiereAutenticacion"] = this.requiereAutenticacion;
		return data;
	}
}

export interface ICarpetaDTO {
	id?: number;
	titulo: string;
	notas?: NotaDTO[] | undefined;
	cantidadDeNotas?: number;
	requiereAutenticacion?: boolean;
}

export class LoginDTO implements ILoginDTO {
	usuario!: string;
	password!: string;

	constructor(data?: ILoginDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.usuario = _data["usuario"];
			this.password = _data["password"];
		}
	}

	static fromJS(data: any): LoginDTO {
		data = typeof data === "object" ? data : {};
		let result = new LoginDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["usuario"] = this.usuario;
		data["password"] = this.password;
		return data;
	}
}

export interface ILoginDTO {
	usuario: string;
	password: string;
}

export class LoginResponseDTO implements ILoginResponseDTO {
	exito?: boolean;
	token?: string | undefined;
	error?: string | undefined;

	constructor(data?: ILoginResponseDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.exito = _data["exito"];
			this.token = _data["token"];
			this.error = _data["error"];
		}
	}

	static fromJS(data: any): LoginResponseDTO {
		data = typeof data === "object" ? data : {};
		let result = new LoginResponseDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["exito"] = this.exito;
		data["token"] = this.token;
		data["error"] = this.error;
		return data;
	}
}

export interface ILoginResponseDTO {
	exito?: boolean;
	token?: string | undefined;
	error?: string | undefined;
}

export class NotaDTO implements INotaDTO {
	id?: number;
	titulo!: string;
	cuerpo?: string | undefined;
	fechaHoraCreacion?: Date | undefined;
	fechaHoraEdicion?: Date | undefined;
	carpetaId?: number;
	carpetaTitulo?: string | undefined;

	constructor(data?: INotaDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.titulo = _data["titulo"];
			this.cuerpo = _data["cuerpo"];
			this.fechaHoraCreacion = _data["fechaHoraCreacion"]
				? new Date(_data["fechaHoraCreacion"].toString())
				: <any>undefined;
			this.fechaHoraEdicion = _data["fechaHoraEdicion"]
				? new Date(_data["fechaHoraEdicion"].toString())
				: <any>undefined;
			this.carpetaId = _data["carpetaId"];
			this.carpetaTitulo = _data["carpetaTitulo"];
		}
	}

	static fromJS(data: any): NotaDTO {
		data = typeof data === "object" ? data : {};
		let result = new NotaDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["id"] = this.id;
		data["titulo"] = this.titulo;
		data["cuerpo"] = this.cuerpo;
		data["fechaHoraCreacion"] = this.fechaHoraCreacion
			? this.fechaHoraCreacion.toISOString()
			: <any>undefined;
		data["fechaHoraEdicion"] = this.fechaHoraEdicion
			? this.fechaHoraEdicion.toISOString()
			: <any>undefined;
		data["carpetaId"] = this.carpetaId;
		data["carpetaTitulo"] = this.carpetaTitulo;
		return data;
	}
}

export interface INotaDTO {
	id?: number;
	titulo: string;
	cuerpo?: string | undefined;
	fechaHoraCreacion?: Date | undefined;
	fechaHoraEdicion?: Date | undefined;
	carpetaId?: number;
	carpetaTitulo?: string | undefined;
}

export class ApiException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any,
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any,
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}
