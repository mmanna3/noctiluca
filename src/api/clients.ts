// ----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
// ----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
	) {
		this.http = http ? http : (window as any);
		this.baseUrl = baseUrl ?? "";
	}

	/**
	 * @return Success
	 */
	carpetaAll(): Promise<CarpetaDTO[]> {
		let url_ = this.baseUrl + "/api/Carpeta";
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaAll(_response);
		});
	}

	protected processCarpetaAll(response: Response): Promise<CarpetaDTO[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(CarpetaDTO.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<CarpetaDTO[]>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	carpetaPOST(body: CarpetaDTO | undefined): Promise<CarpetaDTO> {
		let url_ = this.baseUrl + "/api/Carpeta";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaPOST(_response);
		});
	}

	protected processCarpetaPOST(response: Response): Promise<CarpetaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CarpetaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<CarpetaDTO>(null as any);
	}

	/**
	 * @return Success
	 */
	carpetaGET(id: number): Promise<CarpetaDTO> {
		let url_ = this.baseUrl + "/api/Carpeta/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaGET(_response);
		});
	}

	protected processCarpetaGET(response: Response): Promise<CarpetaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CarpetaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<CarpetaDTO>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	carpetaPUT(id: number, body: CarpetaDTO | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/Carpeta/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCarpetaPUT(_response);
		});
	}

	protected processCarpetaPUT(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}

	/**
	 * @return Success
	 */
	notaAll(): Promise<NotaDTO[]> {
		let url_ = this.baseUrl + "/api/Nota";
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaAll(_response);
		});
	}

	protected processNotaAll(response: Response): Promise<NotaDTO[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(NotaDTO.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<NotaDTO[]>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	notaPOST(body: NotaDTO | undefined): Promise<NotaDTO> {
		let url_ = this.baseUrl + "/api/Nota";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaPOST(_response);
		});
	}

	protected processNotaPOST(response: Response): Promise<NotaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = NotaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<NotaDTO>(null as any);
	}

	/**
	 * @return Success
	 */
	notaGET(id: number): Promise<NotaDTO> {
		let url_ = this.baseUrl + "/api/Nota/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_: RequestInit = {
			method: "GET",
			headers: {
				Accept: "text/plain",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaGET(_response);
		});
	}

	protected processNotaGET(response: Response): Promise<NotaDTO> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = NotaDTO.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<NotaDTO>(null as any);
	}

	/**
	 * @param body (optional)
	 * @return Success
	 */
	notaPUT(id: number, body: NotaDTO | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/Nota/{id}";
		if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(body);

		let options_: RequestInit = {
			body: content_,
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
			},
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processNotaPUT(_response);
		});
	}

	protected processNotaPUT(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers,
				);
			});
		}
		return Promise.resolve<void>(null as any);
	}
}

export class CarpetaDTO implements ICarpetaDTO {
	id?: number;
	titulo!: string;
	notas?: NotaDTO[] | undefined;

	constructor(data?: ICarpetaDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.titulo = _data["titulo"];
			if (Array.isArray(_data["notas"])) {
				this.notas = [] as any;
				for (let item of _data["notas"]) this.notas!.push(NotaDTO.fromJS(item));
			}
		}
	}

	static fromJS(data: any): CarpetaDTO {
		data = typeof data === "object" ? data : {};
		let result = new CarpetaDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["id"] = this.id;
		data["titulo"] = this.titulo;
		if (Array.isArray(this.notas)) {
			data["notas"] = [];
			for (let item of this.notas) data["notas"].push(item.toJSON());
		}
		return data;
	}
}

export interface ICarpetaDTO {
	id?: number;
	titulo: string;
	notas?: NotaDTO[] | undefined;
}

export class NotaDTO implements INotaDTO {
	id?: number;
	titulo!: string;
	cuerpo?: string | undefined;
	fechaHora?: Date;
	carpetaId?: number;

	constructor(data?: INotaDTO) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.titulo = _data["titulo"];
			this.cuerpo = _data["cuerpo"];
			this.fechaHora = _data["fechaHora"]
				? new Date(_data["fechaHora"].toString())
				: <any>undefined;
			this.carpetaId = _data["carpetaId"];
		}
	}

	static fromJS(data: any): NotaDTO {
		data = typeof data === "object" ? data : {};
		let result = new NotaDTO();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["id"] = this.id;
		data["titulo"] = this.titulo;
		data["cuerpo"] = this.cuerpo;
		data["fechaHora"] = this.fechaHora ? this.fechaHora.toISOString() : <any>undefined;
		data["carpetaId"] = this.carpetaId;
		return data;
	}
}

export interface INotaDTO {
	id?: number;
	titulo: string;
	cuerpo?: string | undefined;
	fechaHora?: Date;
	carpetaId?: number;
}

export class ApiException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any,
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any,
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}
